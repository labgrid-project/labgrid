#! /usr/bin/env python3
#
# Wrapper script to setup a wireguard VPN and
#
# This is intended to be used via sudo. For example, add via visudo:
# %developers ALL = NOPASSWD: /usr/sbin/labgrid-vpn-helper


import argparse
import subprocess
import sys
import ipaddress
import tempfile
import json
import socket
import shutil
import os
import signal
import random
import string
import yaml
import time
from contextlib import closing, ExitStack
from pathlib import Path


def wait_for_ready(f):
    while True:
        if f.read().strip() == "1":
            return
        f.seek(0)
        time.sleep(0.1)


def get_denylist():
    denylist_file = Path("/etc/labgrid/helpers.yaml")
    try:
        with denylist_file.open() as f:
            data = yaml.load(f, Loader=yaml.SafeLoader)
    except (PermissionError, FileNotFoundError, AttributeError) as e:
        raise Exception(f"No configuration file ({denylist_file}), inaccessable or invalid yaml") from e

    denylist = data.get("vpn-interface", {}).get("denied-interfaces", [])

    if not isinstance(denylist, list):
        raise Exception("No explicit denied-interfaces or not a list, please check your configuration")

    denylist.append("lo")

    return denylist


def main():
    parser = argparse.ArgumentParser(description="Labgrid VPN Helper")
    parser.add_argument("--interface", "-i", help="Target interface", required=True)
    parser.add_argument("--mac-address", "-m", help="Tap MAC address", required=True)

    args = parser.parse_args()

    denylist = get_denylist()
    if args.interface in denylist:
        sys.stderr.write(f"Interface name '{args.interface}' is denied in denylist.\n")
        return 1

    macvtap_name = "lg-" + str(os.getpid())

    with ExitStack() as ctx:
        # Create macvtap
        subprocess.run(
            [
                "ip",
                "link",
                "add",
                "link",
                args.interface,
                macvtap_name,
                "type",
                "macvtap",
                "mode",
                "bridge",
            ],
            check=True,
        )
        ctx.callback(lambda: subprocess.run(["ip", "link", "del", macvtap_name], check=True))

        subprocess.run(
            ["ip", "link", "set", macvtap_name, "addr", args.mac_address],
            check=True,
        )

        p = subprocess.run(
            ["ip", "-j", "link", "show", "dev", macvtap_name],
            stdout=subprocess.PIPE,
            check=True,
        )
        intf_data = json.loads(p.stdout)
        for intf in intf_data:
            if intf["ifname"] == macvtap_name:
                device_name = "/dev/tap" + str(intf["ifindex"])
                break
        else:
            sys.stderr.write("Unable to find interface with name {macvtap_name}\n")
            return 1

        # Create tap
        ready = ctx.enter_context(os.fdopen(os.memfd_create("ready"), "r+"))
        tap_tunnel = ctx.enter_context(
            subprocess.Popen(
                [
                    "labgrid-taptunnel",
                    "--device",
                    device_name,
                    "--tap-name",
                    macvtap_name,
                    "--ready-fd",
                    str(ready.fileno()),
                ],
                pass_fds=(ready.fileno(),),
            )
        )
        ctx.callback(lambda: tap_tunnel.terminate())

        while ready.read().strip() != "1":
            ready.seek(0)
            if tap_tunnel.poll() is not None:
                sys.stderr.write(f"TAP tunnel exited with {tap_tunnel.returncode}")
                return 1
            time.sleep(0.1)

        subprocess.run(["ip", "link", "set", "up", macvtap_name], check=True)

        tap_tunnel.wait()

    return 0


if __name__ == "__main__":
    sys.exit(main())
