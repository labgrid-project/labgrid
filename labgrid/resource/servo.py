"""Servo board (ChromiumOS)

Handles communication with a DUT via the servod daemon and the dut-control
program.

This provides access to DUT's AP serial port as well as reset and recovery
signals.
"""

import os
import subprocess
import time

import attr
from ..factory import target_factory
from .common import NetworkResource, ManagedResource, ResourceManager
from .base import SerialPort
from ..util.helper import processwrapper

# States that ServoComms moves through to get the board ready for use
(STATE_INIT,    # Initial state
 STATE_WAIT,    # Daemon has been started
 STATE_RUNNING, # Daemon seems to be running
 STATE_STARTED, # Daemon has started and is ready to be configured
 STATE_ERROR,   # An error occurred and the daemon won't work
 STATE_READY    # Daemon is ready to accept requests
) = range(6)

class ServoComms(object):
    """Handle communication with a servo board

    This supports starting a servod daemon for the board and checking the
    progress of the daemon. The communications goes through several states,
    culminating in STATE_READY

    Once the servod daemon is ready, the 'dut-control' program can be used to
    communicate with it.

    Log files are created in a subdirectory of the current directory, called
    servo_<port> where <port> is the port number being used. A servodrc_<name>
    file is created with the configuration, where <name> is the name of the
    board.

    Args:
        state (int): Current `STATE_...` of this servo
        pts (str): Pseudo-terminal device name, e.g. '/dev/pts/43' or None if
            not set
        _name (str): Name of board, as per the rc file (e.g. 'samus')
        _port (int): Port number for the servo daemon (e.g. 9900)
        _proc (subprocess.Popen): Subprocess for the servo daemon, or None if
            not started
        _fd (int): File descriptor for the daemon's 'info' file, None if not
        started
        _logs (str): Directory used by the daemon for log files
        _info_file (str): Filename of the daemon's 'info' file
        _buf (str): Buffer containing date read from @info_file. We read out
            from this a line at a time
        _errs (list of str): List of error messages written by servod into the
            @info_file
        _tool_servod (str): Pathname of servod tool
    """
    def __init__(self, name, port, serial, board, logdir, debug):
        self.state = STATE_INIT
        self.pts = None

        self._name = name
        self._port = port
        self._serial = serial
        self._board = board
        self._proc = None
        self._fd = None
        self._logdir = logdir
        self._logs = os.path.join(logdir, f'servod_{self._port}')
        self._info_file = os.path.join(self._logs, 'latest.INFO')
        self._rcfile = os.path.join(logdir, f'servodrc_{self._name}')
        self._buf = b''
        self._errs = []
        self._debug = debug

        path = os.getenv('HDCTOOLS')
        self._tool_servod = os.path.join(path, 'servod')
        self._tool_dutc = os.path.join(path, 'dut-control')

    def remove_logs(self):
        """Remove any pre-existing logs for this daemon"""
        os.system(f'sudo rm -rf "{self._logs}"')

    def start(self):
        """Start the servo daemon and wait until its log file can be accessed"""

        # Remove any old log file and make sure the directory exists
        if os.path.exists(self._info_file):
            os.remove(self._info_file)
        if not os.path.exists(self._logs):
            os.mkdir(self._logs)

        with open(self._rcfile, 'w') as fd:
            print(f'''# Generated by Labgrid

# This file describes servo boards connected to this host.
#
# Line text starting with # to end of line is ignored, as well as empy lines.
#
# Configuration lines consist of up to 4 comma separated fields, the last
# two are optional:
#
# name serial-number port-number board
#
{self._name}, {self._serial}, {self._port}, {self._board}
''', file=fd)
        cmd = ['sudo', self._tool_servod, '--rcfile', self._rcfile, '--name',
               self._name, '--port', str(self._port),
               '--log-dir', self._logdir]
        self._proc = subprocess.Popen(cmd, stdout=subprocess.PIPE,
                                     stderr=subprocess.PIPE)
        self.state = STATE_WAIT
        done = False

        # Wait several seconds for the daemon to actually start
        for _ in range(30):
            if self._proc.poll():
                out = self._proc.communicate(timeout=100)
                raise ValueError(f"servod died: cmd {' '.join(cmd)} output '{out[1]}'")
            if os.path.exists(self._info_file):
                done = True
                break
            time.sleep(.1)
        if not done:
            raise ValueError(f"Timeout starting servod: {' '.join(cmd)}")
        self._fd = os.open(self._info_file, os.O_RDONLY)
        if not self._fd:
            raise ValueError(f"Cannot open file '{self._info_file}'")
        self.state = STATE_RUNNING

    def __del__(self):
        """Make sure the any active process is killed"""
        if self._proc:
            self._proc.kill()

    def process_data(self, data):
        """Process data received from servod, waiting for it to be ready

        Args:
            data (bytes): Bytes to process

        Returns:
            bool: True if servo is ready, False if not
        """
        self._buf += data
        while b'\n' in self._buf:
            pos = self._buf.find(b'\n')
            line = self._buf[:pos]
            self._buf = self._buf[pos + 1:]
            if b'Listening on localhost' in line:
                self.state = STATE_STARTED
                return True
            elif b'ERROR' in line:
                pos = line.rfind(b' - ')
                err = line[pos + 3:]
                if err not in self._errs:
                    if self._debug:
                        print(f"{self._name} got error: {err.decode('utf-8')}")
                    self._errs.append(err)
        return False

    def active(self):
        """Check if servo is active

        Returns:
            bool: True if servo is either ready or on the way to being ready
        """
        if self.state in (STATE_INIT, STATE_ERROR):
            return False
        elif self.state in (STATE_WAIT, STATE_RUNNING):
            if self._proc.poll() is None:
                return True
        elif self.state == STATE_READY:
            return True

    def wait_started(self):
        """Handle any output from servod while we are still starting up"""
        if self.active():
            data = os.read(self._fd, 1000)
            if data:
                self.process_data(data)

    def setup_pts(self):
        """Set up the pseudo terminal ready for use"""
        cmd = [self._tool_dutc, '-p', str(self._port), 'cpu_uart_pty']
        stdout = processwrapper.check_output(cmd)
        self.pts = stdout.strip().split(b':')[-1].decode('utf-8')

        cmd = ['sudo', 'chmod', 'a+rw', self.pts]
        processwrapper.check_output(cmd)

        self.state = STATE_READY
        if self._debug:
            print(f'servo {self._name} is ready on port {self._port}')

    def poll(self):
        """Poll the servod process to nurse it into ready state

        Returns:
            bool: True if servod is ready, False if more work is needed
        """
        if self.state == STATE_INIT:
            self.start()
        elif self.state == STATE_RUNNING:
            self.wait_started()
        elif self.state == STATE_STARTED:
            self.setup_pts()

        return self.state == STATE_READY


@attr.s(eq=False)
class ServodManager(ResourceManager):
    """Resource manager for all the servo boards

    This collects the Servo resources (each representing a servo board) as well
    as the ServodResource resources (each representing functionality provided,
    such as a serial port or reset signal.

    It regularly checks to see if servod boards are available.
    """
    debug = attr.ib(default=False, validator=attr.validators.instance_of(bool))

    def __attrs_post_init__(self):
        """Set up after attributes are ready

        Properties:
            _servos (list of Servo): List of available servo boards
            _all_ready (bool): True if all servo boards are ready for use
        """
        super().__attrs_post_init__()
        self._servos = []
        self._all_ready = False

    def find_servo_by_name(self, name):
        """Look up a servo by name

        Args:
            name (str): Name to look up

        Returns:
            Servo: object matching the given name, or None if none
        """
        for servo in self._servos:
            if servo.servo_name == name:
                return servo

    def on_resource_added(self, resource):
        """Handle a new resource being added

        For Servo objects this creates a new ServoComms object. For
        ServodResource it tells the resource which Servo it is using.

        Args:
            resource: Resource being added (either Servo or ServoResource)
        """
        if isinstance(resource, Servo):
            servo = resource
            comms = ServoComms(servo.servo_name, servo.port, servo.serial,
                               servo.board, '.', self.debug)
            servo.set_comms(comms)
            self._servos.append(servo)
        elif isinstance(resource, ServodResource):
            servo = self.find_servo_by_name(resource.servo_name)
            resource.set_servo(servo)

    def poll(self):
        """Handle communications polling"""
        for servo in self._servos:
	        servo.comms.poll()
        self._check_all_ready()

    def _check_all_ready(self):
        """Check if all servos are now ready and write out a message if so"""
        if not self._all_ready:
            num_pending = 0
            for servo in self._servos:
                if servo.comms.state != STATE_READY:
                    num_pending += 1
            if not num_pending:
                self._all_ready = True
                print(f'Servo boards are ready (total {len(self._servos)})')


@target_factory.reg_resource
@attr.s(eq=False)
class Servo(ManagedResource):
    """This resource describes a servo board with servod server

    This provides serial consoles along with reset control

    Args:
        serial (str): serial number of the servo device
        port (int): port index to use for servod process
        board (str): board name to use with servod
    """
    manager_cls = ServodManager

    servo_name = attr.ib(validator=attr.validators.instance_of(str))
    serial = attr.ib(validator=attr.validators.instance_of(str))
    port = attr.ib(validator=attr.validators.instance_of(int),
                    converter=int)
    board = attr.ib(default='', validator=attr.validators.instance_of(str))

    # ServoComms object
    comms = None

    def __attrs_post_init__(self):
        super().__attrs_post_init__()

    def set_comms(self, comms):
        """Set up the comms object

        Args:
            comms (ServoComms): comms object to set
        """
        self.comms = comms

    # Overwrite the avail attribute with our internal property
    @property
    def avail(self):
        """Check if the resource is available

        Returns:
            bool: True if available
        """
        return bool(self.comms and self.comms.state == STATE_READY)

    # Forbid the Resource super class to set the avail property
    @avail.setter
    def avail(self, prop):
        pass

    # Overwrite the poll function. Only mark the port as available if both
    # paths are available.
    def poll(self):
        super().poll()


class ServodResource(ManagedResource):
    """Base class for any resources provided by the servo board"""
    manager_cls = ServodManager

    # Servo board being used, set by up ServodManager.on_resource_added()
    servo = None
    ready = False

    def __attrs_post_init__(self):
        super().__attrs_post_init__()

    def set_servo(self, servo):
        self.servo = servo

    # Overwrite the avail attribute with our internal property
    @property
    def avail(self):
        self.ready = bool(self.servo and self.servo.avail)
        return self.ready

    # Forbid the Resource super class to set the avail property
    @avail.setter
    def avail(self, prop):
        pass


@target_factory.reg_resource
@attr.s(eq=False)
class ServoSerialPort(SerialPort, ServodResource):
    """serialport which is available on a servo board."""
    servo_name = attr.ib(default='', validator=attr.validators.instance_of(str))

    def __attrs_post_init__(self):
        super().__attrs_post_init__()

    # Overwrite the avail attribute with our internal property
    @property
    def avail(self):
        ready = super().avail
        self.port = self.servo.comms.pts if ready else None
        return ready

    # Forbid the Resource super class to set the avail property
    @avail.setter
    def avail(self, prop):
        pass


@target_factory.reg_resource
@attr.s(eq=False)
class ServoReset(ServodResource):
    """CPU reset which is available on a servo board."""
    servo_name = attr.ib(default='', validator=attr.validators.instance_of(str))

    def __attrs_post_init__(self):
        super().__attrs_post_init__()


@target_factory.reg_resource
@attr.s(eq=False)
class ServoRecovery(ServodResource):
    """"Recovery button on a remote servo board"""
    servo_name = attr.ib(default='', validator=attr.validators.instance_of(str))

    def __attrs_post_init__(self):
        super().__attrs_post_init__()


@target_factory.reg_resource
@attr.s(eq=False)
class NetworkServo(NetworkResource):
    """"This resource describes a remote servo board with servod server

    This provides serial consoles along with reset control

    Args:
        servo_name (str): name of servo board, e.g. 'my-samus'
        serial (str): serial number of the servo device
        port (int): port index to use for servod process
        board (str): board configurati
    """
    # Overwrite the avail attribute with our internal property
    servo_name = attr.ib(validator=attr.validators.instance_of(str))
    serial = attr.ib(validator=attr.validators.instance_of(str))
    port = attr.ib(validator=attr.validators.instance_of(int),
                    converter=int)
    board = attr.ib(validator=attr.validators.instance_of(str))


@target_factory.reg_resource
@attr.s(eq=False)
class NetworkServoReset(NetworkResource):
    """"This resource describes CPU reset on a remote servo board

    This provides CPU reset

    Args:
        servo_name (str): name of servo board, e.g. 'my-samus'
        serial (str): serial number of the servo device
        port (int): port index to use for servod process
        board (str): board configuration to use, e.g. "samus"
    """
    servo_name = attr.ib(validator=attr.validators.instance_of(str))

    def __attrs_post_init__(self):
        super().__attrs_post_init__()

    def poll(self):
        """Updates the state with new information from the event loop

        Returns:
            None
        """
        pass


@target_factory.reg_resource
@attr.s(eq=False)
class NetworkServoRecovery(NetworkResource):
    """"This resource describes a remote servo board with servod server

    This provides serial consoles along with reset control

    Args:
        servo_name (str): name of servo board, e.g. 'my-samus'
        serial (str): serial number of the servo device
        port (int): port index to use for servod process
        board (str): board configuration to use, e.g. "samus"
    """
    servo_name = attr.ib(validator=attr.validators.instance_of(str))

    def __attrs_post_init__(self):
        super().__attrs_post_init__()
        self.servod_port = None

    def poll(self):
        """Updates the state with new information from the event loop

        Returns:
            None
        """
        pass
